# 处理机管理(进程管理)

    当进程被创建,操作系统会为该进程分配一个唯一的标识:PID(Process ID)

![image_2024-03-04-14-04-26](img/image_2024-03-04-14-04-26.png)

操作系统记录的所有信息都存储在一个数据结构PCB(Process control block)中,即进程控制块

![PCB](img/PCB.png)

# 进程的组成

![image_2024-03-04-14-11-27](img/image_2024-03-04-14-11-27.png)

![image_2024-03-04-14-10-58](img/image_2024-03-04-14-10-58.png) 

# 进程的特性

![image_2024-03-04-14-15-02](img/image_2024-03-04-14-15-02.png)

# 总结

![image_2024-03-04-14-15-30](img/image_2024-03-04-14-15-30.png) 

# 进程的状态和转化

![states-of-process](img/states-of-process.png)

# 总结

![image_2024-03-04-14-39-18](img/image_2024-03-04-14-39-18.png) 

# 进程控制

![image_2024-03-04-14-45-13](img/image_2024-03-04-14-45-13.png)
 
### 创建原语

![image_2024-03-04-14-45-32](img/image_2024-03-04-14-45-32.png)

### 撤销原语

![image_2024-03-04-14-47-27](img/image_2024-03-04-14-47-27.png)


### 阻塞原语

![image_2024-03-04-14-49-55](img/image_2024-03-04-14-49-55.png) 

### 切换原语

![image_2024-03-04-14-51-03](img/image_2024-03-04-14-51-03.png)

# 总结
 
![image_2024-03-04-15-09-06](img/image_2024-03-04-15-09-06.png)

# 进程通信

# 共享存储

![image_2024-03-05-21-12-41](img/image_2024-03-05-21-12-41.png) 

# 消息通信

# 管道通信
![image_2024-03-05-21-13-55](img/image_2024-03-05-21-13-55.png)

    管道只能实行半双工通信,如果要实现全双工通信,那么就要向操作系统申请两个管道
    每个进程互斥的访问管道(操作系统实现)
    管道写满的时候,写进程被阻塞
    管道为空的时候,读进程被阻塞
    管道中的数据一旦被读取就会消失,所以多个进程读取的时候可能会出现问题,(标准答案是可以有多个写进程但是只能有一个读进程,但是实际上通过操作系统的调度可以实现多个读进程<linux>)

# 总结
![image_2024-03-05-21-20-23](img/image_2024-03-05-21-20-23.png) 

# 线程多线程模型

# 线程引入带来的变化

![image_2024-03-05-21-31-31](img/image_2024-03-05-21-31-31.png)

# 线程的属性
![image_2024-03-05-21-32-23](img/image_2024-03-05-21-32-23.png) 

#  多线程模型

![image_2024-03-05-21-40-51](img/image_2024-03-05-21-40-51.png)
![image_2024-03-05-21-41-08](img/image_2024-03-05-21-41-08.png)
![image_2024-03-05-21-41-23](img/image_2024-03-05-21-41-23.png)

# 总结
![image_2024-03-05-21-43-39](img/image_2024-03-05-21-43-39.png)

# 线程的状态与转换

![image_2024-03-05-21-51-47](img/image_2024-03-05-21-51-47.png)


# 处理机调度
![image_2024-03-05-21-59-05](img/image_2024-03-05-21-59-05.png)


当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理 这些任务的顺序，这就是“调度”研究的问题。

# 七状态模型

![image_2024-03-05-22-13-35](img/image_2024-03-05-22-13-35.png)


# 调度的联系对比
![image_2024-03-05-22-14-06](img/image_2024-03-05-22-14-06.png) 

# 总结
![image_2024-03-05-22-14-57](img/image_2024-03-05-22-14-57.png) 

# 进程调度

# 进程调度的时机
![image_2024-03-07-14-18-26](img/image_2024-03-07-14-18-26.png)

# 进程调度的方式
![image_2024-03-07-14-22-39](img/image_2024-03-07-14-22-39.png) 
    
实现简单,系统开销小但是无法处理紧急任务,适用于早期的批处理系统

![image_2024-03-07-14-23-25](img/image_2024-03-07-14-23-25.png)

可以优先处理紧急任务,让进程按时间片轮流执行,适合[分时操作系统,实时操作系统](./chapter1.md@L46)

# 进程调度和进程切换
![image_2024-03-07-14-30-20](img/image_2024-03-07-14-30-20.png)

    狭义就是可以不切换进程，可以继续选择刚才的；广义的就是:不行，你必须切换另一个进程

# 总结

![image_2024-03-07-14-33-05](img/image_2024-03-07-14-33-05.png)

# 闲逛进程
![image_2024-03-07-14-36-22](img/image_2024-03-07-14-36-22.png) 

# 评价调度算法的指标

![image_2024-03-07-14-37-06](img/image_2024-03-07-14-37-06.png)

    cpu利用率:cpu 使用时间/运行总时间
    系统吞吐量:单位时间内完成的作业量
    周转时间:作业提交给系统到作业被完成的时间,由此可以提出平均周转时间
    带权周转时间:作业周转时间/作业实际运行的时间=(作业完成时间-作业提交时间)/作业实际运行时间
        可以看出带权周转时间肯定是大于等于 1 的,同时带权周转时间越小越好
        同理有平均带全周转时间
    等待时间:作业/进程处于处理机等待状态时间的和
    响应时间:用户提交请求到首次被响应的时间 
   ![image_2024-03-07-14-45-07](img/image_2024-03-07-14-45-07.png) 
        
    这里注意阻塞态不计入等待时间(等待I/O设备)

# 总结
![image_2024-03-07-14-46-54](img/image_2024-03-07-14-46-54.png)

# 几种调度算法
![image_2024-03-07-14-47-19](img/image_2024-03-07-14-47-19.png)

![image_2024-03-07-15-27-07](img/image_2024-03-07-15-27-07.png)
![image_2024-03-07-15-31-58](img/image_2024-03-07-15-31-58.png)

![image_2024-03-07-15-45-04](img/image_2024-03-07-15-45-04.png)


## 时间片轮转调度算法
![image_2024-03-07-21-04-46](img/image_2024-03-07-21-04-46.png)

## 优先级调度算法
![image_2024-03-07-21-09-00](img/image_2024-03-07-21-09-00.png)
![image_2024-03-07-21-09-21](img/image_2024-03-07-21-09-21.png) 
![image_2024-03-07-21-11-45](img/image_2024-03-07-21-11-45.png)

    非抢占性算法只需考虑进程主动放弃处理机的情况
    抢占性算法在每次就绪队列更新的时候也需要检测是否需要重新调度 


## 多级反馈队列调度算法
![image_2024-03-07-21-16-56](img/image_2024-03-07-21-16-56.png)
(UNIX 就是使用多级反馈队列调度算法)

![image_2024-03-07-21-22-02](img/image_2024-03-07-21-22-02.png)
分析这里每个队列选择的算法的原因(这只是个例子,并不是真是这样)

# 进程同步进程互斥
![image_2024-03-07-21-41-39](img/image_2024-03-07-21-41-39.png)

# 进程互斥的软件实现方法

![image_2024-03-07-21-50-29](img/image_2024-03-07-21-50-29.png)
![image_2024-03-07-21-53-56](img/image_2024-03-07-21-53-56.png)
![image_2024-03-07-22-16-51](img/image_2024-03-07-22-16-51.png)
![image_2024-03-07-22-22-45](img/image_2024-03-07-22-22-45.png)

# 总结
![image_2024-03-07-22-22-58](img/image_2024-03-07-22-22-58.png)

# 进程互斥的硬件实现方法

中断屏蔽方法![image_2024-03-08-17-43-11](img/image_2024-03-08-17-43-11.png)

TestAndSet 指令![image_2024-03-08-17-45-51](img/image_2024-03-08-17-45-51.png)

Swap指令![image_2024-03-09-13-31-48](img/image_2024-03-09-13-31-48.png)

---

# 互斥锁

![image_2024-03-09-13-35-49](img/image_2024-03-09-13-35-49.png)


# 信号量机制
![image_2024-03-09-13-58-45](img/image_2024-03-09-13-58-45.png)












