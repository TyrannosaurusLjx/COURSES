# 处理机管理(进程管理)

    当进程被创建,操作系统会为该进程分配一个唯一的标识:PID(Process ID)

![image_2024-03-04-14-04-26](img/image_2024-03-04-14-04-26.png)

操作系统记录的所有信息都存储在一个数据结构PCB(Process control block)中,即进程控制块

![PCB](img/PCB.png)

# 进程的组成

![image_2024-03-04-14-11-27](img/image_2024-03-04-14-11-27.png)

![image_2024-03-04-14-10-58](img/image_2024-03-04-14-10-58.png) 

# 进程的特性

![image_2024-03-04-14-15-02](img/image_2024-03-04-14-15-02.png)

# 总结

![image_2024-03-04-14-15-30](img/image_2024-03-04-14-15-30.png) 

# 进程的状态和转化

![states-of-process](img/states-of-process.png)

# 总结

![image_2024-03-04-14-39-18](img/image_2024-03-04-14-39-18.png) 

# 进程控制

![image_2024-03-04-14-45-13](img/image_2024-03-04-14-45-13.png)
 
### 创建原语

![image_2024-03-04-14-45-32](img/image_2024-03-04-14-45-32.png)

### 撤销原语

![image_2024-03-04-14-47-27](img/image_2024-03-04-14-47-27.png)


### 阻塞原语

![image_2024-03-04-14-49-55](img/image_2024-03-04-14-49-55.png) 

### 切换原语

![image_2024-03-04-14-51-03](img/image_2024-03-04-14-51-03.png)

# 总结
 
![image_2024-03-04-15-09-06](img/image_2024-03-04-15-09-06.png)

# 进程通信

# 共享存储

![image_2024-03-05-21-12-41](img/image_2024-03-05-21-12-41.png) 

# 消息通信

# 管道通信
![image_2024-03-05-21-13-55](img/image_2024-03-05-21-13-55.png)

    管道只能实行半双工通信,如果要实现全双工通信,那么就要向操作系统申请两个管道
    每个进程互斥的访问管道(操作系统实现)
    管道写满的时候,写进程被阻塞
    管道为空的时候,读进程被阻塞
    管道中的数据一旦被读取就会消失,所以多个进程读取的时候可能会出现问题,(标准答案是可以有多个写进程但是只能有一个读进程,但是实际上通过操作系统的调度可以实现多个读进程<linux>)

# 总结
![image_2024-03-05-21-20-23](img/image_2024-03-05-21-20-23.png) 

# 线程多线程模型

# 线程引入带来的变化

![image_2024-03-05-21-31-31](img/image_2024-03-05-21-31-31.png)

# 线程的属性
![image_2024-03-05-21-32-23](img/image_2024-03-05-21-32-23.png) 

#  多线程模型

![image_2024-03-05-21-40-51](img/image_2024-03-05-21-40-51.png)
![image_2024-03-05-21-41-08](img/image_2024-03-05-21-41-08.png)
![image_2024-03-05-21-41-23](img/image_2024-03-05-21-41-23.png)

# 总结
![image_2024-03-05-21-43-39](img/image_2024-03-05-21-43-39.png)

# 线程的状态与转换

![image_2024-03-05-21-51-47](img/image_2024-03-05-21-51-47.png)


# 处理机调度
![image_2024-03-05-21-59-05](img/image_2024-03-05-21-59-05.png)


当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理 这些任务的顺序，这就是“调度”研究的问题。

# 七状态模型

![image_2024-03-05-22-13-35](img/image_2024-03-05-22-13-35.png)


# 调度的联系对比
![image_2024-03-05-22-14-06](img/image_2024-03-05-22-14-06.png) 

# 总结
![image_2024-03-05-22-14-57](img/image_2024-03-05-22-14-57.png) 

# 进程调度

# 进程调度的时机
![image_2024-03-07-14-18-26](img/image_2024-03-07-14-18-26.png)

# 进程调度的方式
![image_2024-03-07-14-22-39](img/image_2024-03-07-14-22-39.png) 
    
实现简单,系统开销小但是无法处理紧急任务,适用于早期的批处理系统

![image_2024-03-07-14-23-25](img/image_2024-03-07-14-23-25.png)

可以优先处理紧急任务,让进程按时间片轮流执行,适合[分时操作系统,实时操作系统](./chapter1.md@L46)

# 进程调度和进程切换
![image_2024-03-07-14-30-20](img/image_2024-03-07-14-30-20.png)

    狭义就是可以不切换进程，可以继续选择刚才的；广义的就是:不行，你必须切换另一个进程

# 总结

![image_2024-03-07-14-33-05](img/image_2024-03-07-14-33-05.png)

# 闲逛进程
![image_2024-03-07-14-36-22](img/image_2024-03-07-14-36-22.png) 

# 评价调度算法的指标

![image_2024-03-07-14-37-06](img/image_2024-03-07-14-37-06.png)

    cpu利用率:cpu 使用时间/运行总时间
    系统吞吐量:单位时间内完成的作业量
    周转时间:作业提交给系统到作业被完成的时间,由此可以提出平均周转时间
    带权周转时间:作业周转时间/作业实际运行的时间=(作业完成时间-作业提交时间)/作业实际运行时间
        可以看出带权周转时间肯定是大于等于 1 的,同时带权周转时间越小越好
        同理有平均带全周转时间
    等待时间:作业/进程处于处理机等待状态时间的和
    响应时间:用户提交请求到首次被响应的时间 
   ![image_2024-03-07-14-45-07](img/image_2024-03-07-14-45-07.png) 
        
    这里注意阻塞态不计入等待时间(等待I/O设备)

# 总结
![image_2024-03-07-14-46-54](img/image_2024-03-07-14-46-54.png)

# 几种调度算法
![image_2024-03-07-14-47-19](img/image_2024-03-07-14-47-19.png)

![image_2024-03-07-15-27-07](img/image_2024-03-07-15-27-07.png)
![image_2024-03-07-15-31-58](img/image_2024-03-07-15-31-58.png)

![image_2024-03-07-15-45-04](img/image_2024-03-07-15-45-04.png)







