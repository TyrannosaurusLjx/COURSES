# 哈希(hash)
以常数平均时间执行插入,删除和查找的技术,但是元素之间的任何序信息都不会得到有效的支持,因此诸如finMin,finMax的方法都是不支持的

当我们在编程过程中，往往需要对 线性表$Q$进行查找操作。在顺序表中查找时，需要从表头开始，依次遍历比较$a[i]$们与key的值是 否相等，直到相等才返回索引$i$；在有序表中查找时，我们经常使用的是二分查找，通过比较key与a门的大小来折半查找，直到相等时才返 回索引。最终通过索引找到我们要找的元素。 但是，这两种方法的效率都依赖于 查找中比较的次数。我们有一种想法，能不能不经过比较，而是直接通过关键宇key一次得到所 要的结果呢？ 这时，就有了散列表查找 （哈希表$Q$）。

### hash function的设计理念
    尽可能让被hash的key均匀的分布在hash table中,尽量避免hash碰撞
    对于key是数字的情况,可以直接使用key%table_size作为hash function,或者采用平方取中法等等

### 处理hash碰撞
    1.分离链接法:其做法是将散列到同一个值的所有元素保留在一个链表中.    
        在这种情况下,search的过程中先用hash函数找到对应的链表,再在表中进行查找
    2.(不使用链表),创建一个hash函数列,一旦前一个hash发生了碰撞就采用下一个hash函数,这里
$$h_i(x)=hash(x)+f(i) \mod TableSize\;.here\;f(0)=0 $$
        
        2.1线形探测法(Linear Probing)( f(i)=i ):其做法是当发生hash碰撞时,在hash table中找到下一个空的位置,将元素插入到该位置中.比如
        list=[1,4, , , , , , , ,10](hash table size = 10),hash function为key%10,当插入11,此时11%10=1,但是list[1]已经有元素了,发生hash碰撞,因此我们继续向后寻找,直到找到一个空的位置,将11插入到该位置中.也就是list[2]
        ->list=[1,4,11, , , , , , ,10]
        <这种做法的缺点是某些元素会聚集在一起,插入元素的时候会一直需要往下探测>
        2.2平方探测法(Quadratic Probing):( f(i) = i^2 ),这样第一次碰撞后往下移一位,如果再碰撞就移4位,然后9位,以此类推(是在hash(x)的基础上进行的)
        这里有一个定理:在平方探测下,如果表的大小是素数,那么当表至少有一半的空的时候,总能够插入一个新的元素

    3.双散列法(Double Hashing):做两个hash函数,然后令
    
$$f(i) = ihash_2(x)\Rightarrow h_i(x)=hash_1(x)+ihash_2(x)$$
    
    4.再散列(Rehashing):hash表填的太满的时候(比如超过一半或者十分之一或者某一次hash失败以后),重建一个更大的(一般是两倍)新表,然后将原来的表中的元素重新插入到新表中.

### summary:
    hash表可以在常数平均时间内实现insert和contains操作,适用于不用做过多修改的数据,比如学生信息的记录 hash(学号)=专业,住址...

    装填因子=key个数/TableSize,装填因子越大,hash表的效率越低,因此需要定期rehashing
    
        
    
        




